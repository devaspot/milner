{"name":"ML Language","tagline":"Tiny Lazy ML with Process Calculus in plain C","body":"LML with CCS\r\n============\r\n\r\nLazy ML with Calculus of Communicating Systems (introduced by Robin Milner).\r\nЯзык который предназначен для образовательных целей, что бы можно было\r\n\"на пальцах\" показать, как создать функциальный язык основанный на λ-исчислении.\r\nДля перчинки в язык инкапсулированы ленивость и исчисление процессов,\r\nпредложенное Робином Милнером.\r\n\r\nОперации виртуальной машины\r\n---------------------------\r\n\r\nСериализованное дерево исполняемой программы представляет\r\nсобой дерево хранящееся в последовательности операторов виртуальной машины.\r\nОно может быть полностью декомпилировано в исходный код программы.\r\n\r\n    quote\r\n    lambda\r\n    application\r\n    block\r\n    expression\r\n    decln\r\n    declist\r\n    ifexp\r\n    matchexp\r\n\r\nСреда виртуальной машины\r\n------------------------\r\n\r\nСреда именованых значений представляет собой список именованых значений.\r\nСамо значение представляет собой...\r\n\r\n    proc     | , ||\r\n    ioproc   c ? x -> ..., c ! e -> ...\r\n    value    .\r\n    list\r\n    func\r\n\r\nКонтекст исполнения\r\n-------------------\r\n\r\n    struct exec_ctx {\r\n        int evals, envcells, conscells; // statistics \r\n        alfa LastId;                 { debugging}\r\n        int64 processvalues;\r\n        int ChannelCntr;\r\n        vaue Processes, OutputChan, OutputProc, InputChan, InputProc;\r\n        tree OutputMsg, InputMsg, OutputCont, InputCont;\r\n        env SysEnv;\r\n        int n;\r\n    } exec_ctx;\r\n\r\nВыражения языка\r\n---------------\r\n\r\nПри описании базовой структуры ML подязыка использовался минималистичный набор выражений,\r\nнеобходимый для демонстрации исчисления процессов. Поэтому в языке не реализованый такие\r\nвозможности как pattern matching и система типов.\r\n\r\nТаким образом, базовая часть лямбда исчисления представляет собой только фунциональные\r\nопределения и выражение, так называемый let rec.\r\n\r\n    program ::= exp\r\n    exp ::= ident | numeral | 'letter' | () | true | false | nil |\r\n        ( exp ) | unopr exp | exp binopr exp |\r\n        if exp then exp else exp |\r\n        lambda param . exp  |  exp exp |\r\n        let [rec] decs in exp\r\n    decs  ::= dec , decs | dec\r\n    dec   ::= ident = exp\r\n    param ::= () | ident\r\n    unopr ::= head | tail | null | not | -\r\n    binopr ::= and | or | = | <> | < | <= | > | >= | + | - | * | / | ::\r\n    priorities:\r\n\t    ::                   1 cons list (right associative)\r\n\t    or                   2\r\n\t    and                  3\r\n\t    = <> < <= > >=       4 scalars only\r\n\t    + -                  5 { binary - }\r\n\t    * /                  6\r\n\t    application          7 { left associative, f x y = (f(x))(y) }\r\n\t    - head tail null not 8 { unary - }\r\n\r\nЧасть языка, котая отвечает за исчисление процессов моделирует\r\n\r\n    processes:\r\n        process1 || process2       p1 and p2 in parallel\r\n        process1 |  process2       choice of either p1 or p2\r\n        action -> process          sequence\r\n        stop                       null process\r\n\r\nСуществует известное ограничивающее правило находжения оператора || ниже\r\nоператора | Например выражение (p1||p2)|p3 является недопустимым.\r\n\r\n    actions:\r\n        channel ? variable         input  action\r\n        channel ! expression       output action\r\n\r\n    channels:\r\n        let c=chan in ...          chan returns a new channel\r\n        output                     standard ouput channel\r\n        input                      standard input channel\r\n\r\nМаксим Сохацкий (maxim@synrc.com)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}